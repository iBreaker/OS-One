OS ONE TroubleShooting
=====
*2015-2-09 19:49:45*

这里不是所有的问题都会记录,只会记录一些对以后开发有用处的错误

### #1    重复调用drawStringF出现杂点
*	*2015年02月10日12:57:09*    
*	初步判断是`printf`函数的问题   
*	确认是任务切换寄存器恢复的问题  
*	`r0`和`r1`寄存器恢复次序颠倒导致未知错误   
*	*2015年02月11日21:43:18*  **已解决**
  
### #2   printf相关的函数有问题,尤其是%x 和 %f输出的时候
*	*2015年02月20日17:51:32*

### #3   GPIO_SET_GPFSEL 函数有问题
*	*2015年02月20日17:52:04*
*	*2015年02月24日14:10:11*  **已解决**
   
### #4	send MSG 有可能使系统进入死循环   
*	*2015年02月20日17:29:47*
*	初步判断是printf函数的问题 `task_send_msg` 函数的问题  
*	确认是任`MSG_dispose`函数的问题  将调试信息打印到屏幕,发现是任务调度函数中处理消息的函数有问题,上一个任务的消息没有清除,当做当前任务的消息,而改变了当前任务的状态,使任务不能正常调度,当所有的任务都不能被调度的时候,调度函数进入死循环,此时系统中断也处于关闭状态
*	2*015年02月20日18:03:44*  已解决
    
### #5	图层复制的时候出现莫名其妙的错误,颜色不正确
*	*2015-02-27 17:06:03*  
*	`C`语言中结构体不能直接赋值,`c++`中可以,必须逐一赋值  
*	*2015年02月27日17:12:56*   **已解决**  
     
### #6	图层设置有问题
*	*2015年03月05日19:07:01*  
*	*2015年03月09日22:08:03*  **已解决**   
    
### #7	UART中断无法正常返回
*	*2015年03月09日22:08:54*    
*	用控制变量法确定是`UART_irq_handler`函数的问题。具体是这个函数什么问题还不知道   
*	将函数换成`sleep(500)`, 要是这次UART数据还没有处理完在发生中断就会产生这种情况，所以不是`UART_irq_handler`函数本身的问题  
*	问题原因是自己写的中断返回代码中，先恢复`cpsr`的值，在`pc`恢复之前开启了中断。这时候在发生一次中断，`r0`， `r1`， `pc`的值会出现问题  
*	解决办法，先判断是UART中断还是timer中断。然后根据两种情况写不同的返回代码。
    
    